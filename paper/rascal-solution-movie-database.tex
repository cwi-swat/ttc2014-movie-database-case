\documentclass[submission,copyright,creativecommons]{eptcs}
\providecommand{\event}{TTC 2014} % Name of the event you are submitting to
\usepackage{breakurl}             % Not needed if you use pdflatex only.
\usepackage{rascal}
\usepackage[T1]{fontenc}
\usepackage[scaled=0.8]{beramono}
\title{The TTC 2014 Movie Database Case: Rascal Solution\thanks{This
    research was supported by the Netherlands Organisation for
    Scientific Research (NWO) Jacquard Grant ``Next Generation
    Auditing: Data-Assurance as a service'' (638.001.214).}}
\author{Pablo Inostroza \and Tijs van der Storm}
\def\authorrunning{Inostroza and Van der Storm}
\def\titlerunning{TTC'14: Rascal}

\begin{document}
\maketitle

\begin{abstract}
Rascal is meta programming language for processing source code in the broad sense (models, documents, formats, languages, etc.). In this short note we discuss the implementation of the ``TTC'14 Movie Database Case'' in Rascal. In particular we will highlight the challenges and benefits of using a functional programming language for transformation what is, in essence, a large graph. 
\end{abstract}

\section{Introduction}

Rascal is a meta programming language for source code analysis and transformation~\cite{Rascal,RascalGTTSE}. 
Concretely, it is targeted at analyzing and processing any kind of ``source code in the broad sense''; this includes importing, analyzing, transforming, visualizing and generating, models, data files, program code, documentation etc.
 
Although Rascal features a Java-like syntax, it is a functional programming in that all data is immutable (implemented using persistent data structures), and function programming concepts are used throughout: algebraic data types, pattern matching, higher-order functions, comprehensions etc. 

Specifically for the domain of source code manipulation, however, Rascal features powerful primitives for parsing (context-free grammars), traversal (visit statement), relational analysis (transitive closure, image etc.), and code generation (string templates). 
The standard library includes programming language grammars (e.g., Java), IDE integration
with Eclipse, numerous importers (e.g. XML, CSV, YAML, JSON etc.) and a rich visualization framework. 

\subsection{Representing IMDB in Rascal}

Since Rascal is a functional programming language, where all data is immutable, the IMDB models have to be represented as trees instead of graphs. If there are cross references in the model, these have to be represented using (symbolic or opaque) identifiers which can be used to look up referenced elements. 

The following data type captures the structure of the IMDB models:
%\CAT{Keyword}{alias} Id = \CAT{Keyword}{int};
\begin{rascal}
\CAT{Keyword}{data} IMDB   = imdb(\CAT{Keyword}{map}{}[Id, Movie] movies, \CAT{Keyword}{map}{}[Id, Person] persons, 
                   \CAT{Keyword}{set}{}[Group] groups, \CAT{Keyword}{rel}{}[Id movie, Id person] stars);
\CAT{Keyword}{data} Movie  = movie(\CAT{Keyword}{str} title, \CAT{Keyword}{real} rating, \CAT{Keyword}{int} year);
\CAT{Keyword}{data} Person = actor(\CAT{Keyword}{str} name) | actress(\CAT{Keyword}{str} name);
\CAT{Keyword}{data} Group  = couple(\CAT{Keyword}{real} avgRating, Id p1, Id p2, \CAT{Keyword}{set}{}[Id] movies);
\end{rascal}

An IMDB model is constructed using the \texttt{imdb} constructor. It contains the set of movies, persons, groups and a relation \texttt{stars} encoding which movie stars which persons. 
Both movies and persons are identified using the opaque \texttt{Id} type. 
To model this identification, the \texttt{movies} and \texttt{persons} field of an IMDB model are maps from such identifiers to the actual movie resp. person. 

Movies and persons are simple values containing the various fields that pertain to them. 



\section{Task 1: Synthesizing Test Data}


\begin{rascal}
IMDB createExample(\CAT{Keyword}{int} N) = createExample(imdb((),(),\{{}\}{},\{{}\}{}), N);
IMDB createExample(IMDB m0, \CAT{Keyword}{int} N) = (m0 | mergeDB(\CAT{Keyword}{it}, createTest(i)) | i \textless{}- {}[\CAT{Keyword}{0}..N]);
IMDB createTest(\CAT{Keyword}{int} i) = mergeDB(createPositive(i), createNegative(i));
    
IMDB createPositive(\CAT{Keyword}{int} i) = imdb(movies, people, groups, stars)
    \CAT{Keyword}{when} movies := ( j: movie(\CAT{Constant}{"m\textless{}}j\CAT{Constant}{\textgreater{}"}, toReal(j), 2013) | j \textless{}- {}[10*i..10*i+5] ),
         people := ( 10*i: actor(\CAT{Constant}{"a\textless{}}10*i\CAT{Constant}{\textgreater{}"}), 10*i+1: actor(\CAT{Constant}{"a\textless{}}10*i+1\CAT{Constant}{\textgreater{}"}), 
                     10*i+2: actor(\CAT{Constant}{"a\textless{}}10*i+2\CAT{Constant}{\textgreater{}"}), 10*i+3: actress(\CAT{Constant}{"a\textless{}}10*i+3\CAT{Constant}{\textgreater{}"}), 
                     10*i+4: actress(\CAT{Constant}{"a\textless{}}10*i+4\CAT{Constant}{\textgreater{}"}) ),
         groups := \{{}\}{},
         stars := \{{}\textless{}10*i, 10*i\textgreater{}, \textless{}10*i, 10*i+1\textgreater{}, \textless{}10*i, 10*i+2\textgreater{}, \textless{}10*i, 10*i+3\textgreater{},
                 \textless{}10*i+1, 10*i\textgreater{}, \textless{}10*i+1, 10*i+1\textgreater{}, \textless{}10*i+1, 10*i+2\textgreater{}, \textless{}10*i+1, 10*i+3\textgreater{},
                 \textless{}10*i+2, 10*i+1\textgreater{}, \textless{}10*i+2, 10*i+2\textgreater{}, \textless{}10*i+2, 10*i+3\textgreater{},
                 \textless{}10*i+3, 10*i+1\textgreater{}, \textless{}10*i+3, 10*i+2\textgreater{}, \textless{}10*i+3, 10*i+3\textgreater{}, \textless{}10*i+3, 10*i+4\textgreater{},
                 \textless{}10*i+4, 10*i+1\textgreater{}, \textless{}10*i+4, 10*i+2\textgreater{}, \textless{}10*i+4, 10*i+3\textgreater{}, \textless{}10*i+4, 10*i+4\textgreater{}\}{};          
\end{rascal}


\section{Task 2: Adding Couples}

\begin{rascal}
\CAT{Keyword}{set}{}[Group] makeCouples(IMDB m) \{{}
    costars = toMap(m.stars); couples = ();
    \CAT{Keyword}{for} (mov \textless{}- costars, s1 \textless{}- costars{}[mov], s2 \textless{}- costars{}[mov], s1 \textless{} s2) 
       couples{}[\textless{}s1, s2\textgreater{}]?\{\} += \{{}mov\}{};
    \CAT{Keyword}{return} \{{} couple(0.0, x, y, ms) 
                     | \textless{}x, y\textgreater{} \textless{}- couples, ms := couples{}[\textless{}x, y\textgreater{}], size(ms) \textgreater{}= 3 \}{};
\}{}
\end{rascal}

\section{Task 3: Computing Average Ratings for Couples}

\begin{rascal}
IMDB addGroupRatings(IMDB m) = m{}[groups=gs]
  \CAT{Keyword}{when} gs :=
    \{{} g{}[avgRating = toReal(mean(ratings))] 
       | g \textless{}- m.groups, ratings := {}[ m.movies{}[x].rating | x \textless{}- g.movies ]\}{};
\end{rascal}

\section{Extension Task 1: Top 15 Rankings}

\begin{rascal}
\CAT{Keyword}{alias} Ranking = \CAT{Keyword}{lrel}{}[\CAT{Keyword}{set}{}[Person], \CAT{Keyword}{real}, \CAT{Keyword}{int}]; 

Ranking rank(\CAT{Keyword}{int} n, IMDB m, \CAT{Keyword}{bool}(Group, Group) gt) =
    take(n, 
       {}[\textless{}\{{}m.persons{}[x] | x \textless{}- getPersons(g)\}{}, g.avgRating, size(g.movies)\textgreater{} 
            | Group g \textless{}- sort(m.groups, gt)]);
\end{rascal}    


\begin{rascal}
Ranking top15avgRating(IMDB m)    = rank(15, m, greaterThan(getRating));    
Ranking top15commonMovies(IMDB m) = rank(15, m, greaterThan(getNumOfMovies));
\end{rascal}

greaterThan, getRating, getNumOfMovies.

\section{Extension Task 2: Generalizing groups to cliques}

\begin{rascal}
\CAT{Keyword}{data} Group = clique(\CAT{Keyword}{real} avgRating, \CAT{Keyword}{set}{}[Id] persons, \CAT{Keyword}{set}{}[Id] movies);
\end{rascal}


\begin{rascal}
\CAT{Keyword}{set}{}[Group] makeCliques(IMDB m, \CAT{Keyword}{int} n) \{{}
    costars = toMap(m.stars); cliques = ();
    \CAT{Keyword}{for} (Id movie \textless{}- costars, \CAT{Keyword}{set}{}[Id] s \textless{}- combinations(costars{}[movie], n))
      cliques{}[s]?\{\} += \{{}movie\}{};
    \CAT{Keyword}{return} \{{}clique(0.0, s, ms) | s \textless{}- cliques, ms := cliques{}[s], size(ms) \textgreater{}= 3 \}{};
\}{}
\end{rascal}

\paragraph{Extension Task 3 \& 4}

These are the same as Task 3 and Extension of Task 1 respectively,
because the code is polymorph over groups.

\section{Concluding Remarks}

The tasks were easy to implement, with little code. The size of the
implementation is around 130 SLOC, including some helper functions,
but excluding loading the model from XML which is another 38 SLOC.

Rascal's module system showed its benefits; some tasks could be
implemented as modular extensions of earlier tasks, combining
extension of data types (Extension Task 2) and extension of functions
(Extension Tasks 3 and 4).

Performance: extracting cliques $> 2$ takes longer than 5 minutes on a
3.3Mb IMDB file. The most probable reason is that
\texttt{combinations} is slow, even though we use a dynamic
programming algorithm; it is possible that immutability works against
us here.

\section{Bibliography}

\nocite{*}
\bibliographystyle{eptcs}
\bibliography{generic}
\end{document}
