\documentclass[submission,copyright,creativecommons]{eptcs}
\providecommand{\event}{TTC 2014} % Name of the event you are submitting to
\usepackage{breakurl}             % Not needed if you use pdflatex only.
\usepackage{rascal}
\usepackage[T1]{fontenc}
\usepackage[scaled=0.8]{beramono}
\title{The TTC 2014 Movie Database Case: Rascal Solution\thanks{This
    research was supported by the Netherlands Organisation for
    Scientific Research (NWO) Jacquard Grant ``Next Generation
    Auditing: Data-Assurance as a service'' (638.001.214).}}
\author{Pablo Inostroza \and Tijs van der Storm}
\def\authorrunning{Inostroza and Van der Storm}
\def\titlerunning{TTC'14: Rascal}

\begin{document}
\maketitle

\begin{abstract}
Rascal is meta programming language for processing source code in the broad sense (models, documents, formats, languages, etc.). In this short note we discuss the implementation of the ``TTC'14 Movie Database Case'' in Rascal. In particular we will highlight the challenges and benefits of using a functional programming language for transformation what is, in essence, a large graph. 
\end{abstract}

\section{Introduction}

Rascal is a meta programming language for source code analysis and transformation~\cite{Rascal,RascalGTTSE}. 
Concretely, it is targeted at analyzing and processing any kind of ``source code in the broad sense''; this includes importing, analyzing, transforming, visualizing and generating, models, data files, program code, documentation etc.
 
Although Rascal features a Java-like syntax, it is a functional programming in that all data is immutable (implemented using persistent data structures), and function programming concepts are used throughout: algebraic data types, pattern matching, higher-order functions, comprehensions etc. 

Specifically for the domain of source code manipulation, however, Rascal features powerful primitives for parsing (context-free grammars), traversal (visit statement), relational analysis (transitive closure, image etc.), and code generation (string templates). 
The standard library includes programming language grammars (e.g., Java), IDE integration
with Eclipse, numerous importers (e.g. XML, CSV, YAML, JSON etc.) and a rich visualization framework. 

\subsection{Representing IMDB in Rascal}

\begin{rascal}
\CAT{Keyword}{alias} Id = \CAT{Keyword}{int};
\CAT{Keyword}{data} IMDB = imdb(\CAT{Keyword}{map}{}[Id, Movie] movies, \CAT{Keyword}{map}{}[Id, Person] persons, 
                  \CAT{Keyword}{set}{}[Group] groups, \CAT{Keyword}{rel}{}[Id movie, Id person] pim);
\CAT{Keyword}{data} Movie = movie(\CAT{Keyword}{str} title, \CAT{Keyword}{real} rating, \CAT{Keyword}{int} year);
\CAT{Keyword}{data} Person 
  = actor(\CAT{Keyword}{str} name) 
  | actress(\CAT{Keyword}{str} name);
\CAT{Keyword}{data} Group = couple(\CAT{Keyword}{real} avgRating, Id p1, Id p2, \CAT{Keyword}{set}{}[Id] movies);
\end{rascal}

\section{Task 1: Synthesizing Test Data}


\begin{rascal}
IMDB createExample(\CAT{Keyword}{int} N) = createExample(imdb((),(),\{{}\}{},\{{}\}{}), N);
IMDB createExample(IMDB m0, \CAT{Keyword}{int} N) = (m0 | mergeDB(\CAT{Keyword}{it}, createTest(i)) | i \textless{}- {}[\CAT{Keyword}{0}..N]);
IMDB createTest(\CAT{Keyword}{int} i) = mergeDB(createPositive(i), createNegative(i));
    
IMDB createPositive(\CAT{Keyword}{int} i) = imdb(movies, people, groups, pim)
    \CAT{Keyword}{when} movies := ( j: movie(\CAT{Constant}{"m\textless{}}j\CAT{Constant}{\textgreater{}"}, toReal(j), 2013) | j \textless{}- {}[10*i..10*i+5] ),
         people := ( 10*i: actor(\CAT{Constant}{"a\textless{}}10*i\CAT{Constant}{\textgreater{}"}), 10*i+1: actor(\CAT{Constant}{"a\textless{}}10*i+1\CAT{Constant}{\textgreater{}"}), 
                     10*i+2: actor(\CAT{Constant}{"a\textless{}}10*i+2\CAT{Constant}{\textgreater{}"}), 10*i+3: actress(\CAT{Constant}{"a\textless{}}10*i+3\CAT{Constant}{\textgreater{}"}), 
                     10*i+4: actress(\CAT{Constant}{"a\textless{}}10*i+4\CAT{Constant}{\textgreater{}"}) ),
         groups := \{{}\}{},
         pim := \{{}\textless{}10*i, 10*i\textgreater{}, \textless{}10*i, 10*i+1\textgreater{}, \textless{}10*i, 10*i+2\textgreater{}, \textless{}10*i, 10*i+3\textgreater{},
                 \textless{}10*i+1, 10*i\textgreater{}, \textless{}10*i+1, 10*i+1\textgreater{}, \textless{}10*i+1, 10*i+2\textgreater{}, \textless{}10*i+1, 10*i+3\textgreater{},
                 \textless{}10*i+2, 10*i+1\textgreater{}, \textless{}10*i+2, 10*i+2\textgreater{}, \textless{}10*i+2, 10*i+3\textgreater{},
                 \textless{}10*i+3, 10*i+1\textgreater{}, \textless{}10*i+3, 10*i+2\textgreater{}, \textless{}10*i+3, 10*i+3\textgreater{}, \textless{}10*i+3, 10*i+4\textgreater{},
                 \textless{}10*i+4, 10*i+1\textgreater{}, \textless{}10*i+4, 10*i+2\textgreater{}, \textless{}10*i+4, 10*i+3\textgreater{}, \textless{}10*i+4, 10*i+4\textgreater{}\}{};          
\end{rascal}


\section{Task 2: Adding Couples}

\begin{rascal}
\CAT{Keyword}{set}{}[Group] makeCouples(IMDB m) \{{}
    costars = toMap(m.pim); couples = ();
    \CAT{Keyword}{for} (mov \textless{}- costars, s1 \textless{}- costars{}[mov], s2 \textless{}- costars{}[mov], s1 \textless{} s2) 
       couples{}[\textless{}s1, s2\textgreater{}]?\{\} += \{{}mov\}{};
    \CAT{Keyword}{return} \{{} couple(0.0, x, y, ms) 
                     | \textless{}x, y\textgreater{} \textless{}- couples, ms := couples{}[\textless{}x, y\textgreater{}], size(ms) \textgreater{}= 3 \}{};
\}{}
\end{rascal}

\section{Task 3: Computing Average Ratings for Couples}

\begin{rascal}
IMDB addGroupRatings(IMDB m) = m{}[groups=gs]
  \CAT{Keyword}{when} gs :=
    \{{} g{}[avgRating = toReal(mean(ratings))] 
       | g \textless{}- m.groups, ratings := {}[ m.movies{}[x].rating | x \textless{}- g.movies ]\}{};
\end{rascal}

\section{Extension Task 1: Top 15 Rankings}

\begin{rascal}
\CAT{Keyword}{alias} Ranking = \CAT{Keyword}{lrel}{}[\CAT{Keyword}{set}{}[Person], \CAT{Keyword}{real}, \CAT{Keyword}{int}]; 

Ranking rank(\CAT{Keyword}{int} n, IMDB m, \CAT{Keyword}{bool}(Group, Group) gt) =
    take(n, 
       {}[\textless{}\{{}m.persons{}[x] | x \textless{}- getPersons(g)\}{}, g.avgRating, size(g.movies)\textgreater{} 
            | Group g \textless{}- sort(m.groups, gt)]);
\end{rascal}    


\begin{rascal}
Ranking top15avgRating(IMDB m)    = rank(15, m, greaterThan(getRating));    
Ranking top15commonMovies(IMDB m) = rank(15, m, greaterThan(getNumOfMovies));
\end{rascal}

greaterThan, getRating, getNumOfMovies.

\section{Extension Task 2: Generalizing groups to cliques}

\begin{rascal}
\CAT{Keyword}{data} Group = clique(\CAT{Keyword}{real} avgRating, \CAT{Keyword}{set}{}[Id] persons, \CAT{Keyword}{set}{}[Id] movies);
\end{rascal}


\begin{rascal}
\CAT{Keyword}{set}{}[Group] makeCliques(IMDB m, \CAT{Keyword}{int} n) \{{}
    costars = toMap(m.pim); cliques = ();
    \CAT{Keyword}{for} (Id movie \textless{}- costars, \CAT{Keyword}{set}{}[Id] s \textless{}- combinations(costars{}[movie], n))
      cliques{}[s]?\{\} += \{{}movie\}{};
    \CAT{Keyword}{return} \{{}clique(0.0, s, ms) | s \textless{}- cliques, ms := cliques{}[s], size(ms) \textgreater{}= 3 \}{};
\}{}
\end{rascal}

\paragraph{Extension Task 3 \& 4}

These are the same as Task 3 and Extension of Task 1 respectively,
because the code is polymorph over groups.

\section{Bibliography}

\nocite{*}
\bibliographystyle{eptcs}
\bibliography{generic}
\end{document}
